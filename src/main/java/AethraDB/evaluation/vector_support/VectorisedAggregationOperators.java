package AethraDB.evaluation.vector_support;

import AethraDB.evaluation.general_support.hashmaps.KeyValueMapGenerator;

/**
 * Class containing vectorised primitives for aggregation operators.
 */
public class VectorisedAggregationOperators extends VectorisedOperators {

    /**
     * Prevent instantiating this class.
     */
    private VectorisedAggregationOperators() {
        super();
    }

    /**
     * Method counting the number of valid entries in a validity mask.
     * @param validityMask The mask to count the number of valid entries in.
     * @param validityMaskLength The length of the valid portion of {@code validityMask}.
     * @return The number of valid entries in {@code validityMask}.
     */
    public static int count(boolean[] validityMask, int validityMaskLength) {
        int validCount = 0;
        for (int i = 0; i < validityMaskLength; i++)
            if (validityMask[i])
                validCount++;
        return validCount;
    }

    /**
     * Method for computing the sum of all valid entries in a vector.
     * @param vector The vector to compute the sum of.
     * @param vectorLength The length of the valid portion of {@code vector}.
     * @return The sum of all entries in {@code vector}.
     */
    public static long vectorSum(int[] vector, int vectorLength) {
        long sum = 0;
        for (int i = 0; i < vectorLength; i++) {
            sum += vector[i];
        }
        return sum;
    }

    /**
     * Method for computing the sum of all valid entries in a vector as indicated by a selection vector.
     * @param vector The vector to compute the sum of.
     * @param vectorLength The length of the valid portion of {@code vector}.
     * @param selectionVector The selection vector indicating the valid entries of {@code vector}.
     * @param selectionVectorLength The length of the valid portion of {@code selectionVector}.
     * @return The sum of all entries in {@code vectorArray}.
     */
    public static double vectorSum(double[] vector, int vectorLength, int[] selectionVector, int selectionVectorLength) {
        double sum = 0d;
        for (int i = 0; i < selectionVectorLength; i++) {
            int selectedIndex = selectionVector[i];
            sum += vector[selectedIndex];
        }
        return sum;
    }

    /**
     * Method for computing the sum of all valid entries in a vector as indicated by a validity mask.
     * @param vector The vector to compute the sum of.
     * @param vectorLength The length of the valid portion of {@code vector}.
     * @param validityMask The mask indicating the valid entries of {@code vector}.
     * @param validityMaskLength The length of the valid portion of {@code validityMask}.
     * @return The sum of all entries in {@code vectorArray}.
     */
    public static double vectorSum(double[] vector, int vectorLength, boolean[] validityMask, int validityMaskLength) {
        double sum = 0d;
        for (int i = 0; i < vectorLength; i++) {
            if (validityMask[i]) {
                sum += vector[i];
            }
        }
        return sum;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param validLength The length of the valid part of {@code sourceArray}.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(int[] resultVector, int[] sourceArray, int validLength, int startIndex) {
        int currentSourceIndex = startIndex;
        int currentResultIndex = 0;
        while (currentSourceIndex < validLength && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentSourceIndex++];
        }
        return currentResultIndex;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param validLength The length of the valid part of {@code sourceArray}.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(long[] resultVector, long[] sourceArray, int validLength, int startIndex) {
        int currentSourceIndex = startIndex;
        int currentResultIndex = 0;
        while (currentSourceIndex < validLength && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentSourceIndex++];
        }
        return currentResultIndex;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param validLength The length of the valid part of {@code sourceArray}.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(double[] resultVector, double[] sourceArray, int validLength, int startIndex) {
        int currentSourceIndex = startIndex;
        int currentResultIndex = 0;
        while (currentSourceIndex < validLength && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentSourceIndex++];
        }
        return currentResultIndex;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param validLength The length of the valid part of {@code sourceArray}.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(byte[][] resultVector, byte[][] sourceArray, int validLength, int startIndex) {
        int currentSourceIndex = startIndex;
        int currentResultIndex = 0;
        while (currentSourceIndex < validLength && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentSourceIndex++];
        }
        return currentResultIndex;
    }

}
