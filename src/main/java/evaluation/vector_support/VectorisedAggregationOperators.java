package evaluation.vector_support;

import evaluation.general_support.hashmaps.KeyValueMapGenerator;

/**
 * Class containing vectorised primitives for aggregation operators.
 */
public class VectorisedAggregationOperators extends VectorisedOperators {

    /**
     * Prevent instantiating this class.
     */
    private VectorisedAggregationOperators() {
        super();
    }

    /**
     * Method counting the number of valid entries in a validity mask.
     * @param validityMask The mask to count the number of valid entries in.
     * @param validityMaskLength The length of the valid portion of {@code validityMask}.
     * @return The number of valid entries in {@code validityMask}.
     */
    public static int count(boolean[] validityMask, int validityMaskLength) {
        int validCount = 0;
        for (int i = 0; i < validityMaskLength; i++)
            if (validityMask[i])
                validCount++;
        return validCount;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(int[] resultVector, int[] sourceArray, int startIndex) {
        int currentMapIndex = startIndex;
        int currentResultIndex = 0;
        while (currentMapIndex < sourceArray.length && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentMapIndex++];
        }
        return currentResultIndex;
    }

    /**
     * Method to construct a vector from a map generated by {@link KeyValueMapGenerator}.
     * @param resultVector The vector to construct into.
     * @param sourceArray The array to construct the vector from.
     * @param startIndex The key index to start the construction from.
     * @return The length of the valid portion of {@code resultVector}.
     */
    public static int constructVector(long[] resultVector, long[] sourceArray, int startIndex) {
        int currentMapIndex = startIndex;
        int currentResultIndex = 0;
        while (currentMapIndex < sourceArray.length && currentResultIndex < VECTOR_LENGTH) {
            resultVector[currentResultIndex++] = sourceArray[currentMapIndex++];
        }
        return currentResultIndex;
    }

}
